#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <string>
#include <string_view>
#include <vector>

#if __cpp_constexpr >= 202211L
#define GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME 1
#else
#define GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME 0
#endif

namespace collisions_gen {

/// @brief Default number of strings generated by @fn generate_strings_with_same_hash
inline constexpr uint32_t kDefaultSize = 2000;

namespace impl {

#if defined(__GNUC__)
using uint128_t = __uint128_t;
#elif defined(_MSC_VER)
#include <__msvc_int128.hpp>
using uint128_t = std::_Unsigned128;
#else
#error "typedef 128-bit integer specific for your compiler"
#endif

inline constexpr uint32_t kPrime         = 31;
inline constexpr uint32_t kDefaultStartN = 1;
/// @brief @f[ \lceil log_{kPrime}( 2^{32} \cdot 2^{64} ) \rceil @f]
inline constexpr uint32_t kMaxZeroRemStringSize = 20;

/// @brief f: { 0, ..., 2^32 - 1 } -> { 0, 1 }
/// @param n
/// @return n |-> n ∈ [1; 26]
constexpr bool between_1_and_26(uint32_t n) noexcept { return n - 1 <= 25; }

/// @brief Checks whether all digits of n
///        in base @ref kPrime ∈ [1; 26]
/// @param n
/// @return
constexpr bool check_n_in_base_p(uint128_t n) noexcept {
    do {
        uint32_t r = uint32_t(n % kPrime);
        n /= kPrime;
        if (!between_1_and_26(r)) {
            return false;
        }
    } while (n);
    return true;
}

/// @brief Finds integer n, such that all digits
///        of n * 2^64 in base @ref kPrime ∈ [1; 26]
/// @tparam StartN
/// @return n
template <uint32_t StartN = kDefaultStartN>
constexpr uint32_t find_zero_rem_num() noexcept {
    for (uint32_t n = StartN;; n++) {
        if (check_n_in_base_p(uint128_t(n) << 64)) {
            return n;
        }
    }
}

template <uint32_t N>
struct ZeroHashStringBuffer {
#if GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
    consteval
#else
    constexpr
#endif
        ZeroHashStringBuffer() noexcept {
        uint128_t m = uint128_t(N) << 64;
        do {
            uint32_t r = uint32_t(m % kPrime);
            m /= kPrime;
            assert(between_1_and_26(r));
            zero_hash_string_buffer_[size_++] = char(r - 1 + 'a');
        } while (m);
    }

#if GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
    consteval
#else
    constexpr
#endif
        std::string_view
        as_string_view() const noexcept {
        return std::string_view(zero_hash_string_buffer_, size_);
    }

    char zero_hash_string_buffer_[kMaxZeroRemStringSize + 1] = {};
    size_t size_                                             = 0;
};

// clang-format off

template <uint32_t StartN = kDefaultStartN>
#if GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
inline constexpr
#else
const
#endif
ZeroHashStringBuffer<find_zero_rem_num<StartN>()> zero_hash_string_buffer;

template <uint32_t StartN = kDefaultStartN>
#if GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
inline constexpr
#else
const
#endif
std::string_view zero_hash_string = zero_hash_string_buffer<StartN>.as_string_view();

// clang-format on

}  // namespace impl

/// @brief Polynomial hash function.
///        This function causes UB and hence not marked constexpr.
/// @param s
/// @return polynomial hash of the @a `s`
long long polynomial_hash(std::string_view s) noexcept {
    constexpr long long p = impl::kPrime;
    long long hash        = 0;
    long long p_pow       = 1;
    for (size_t i = 0; i < s.length(); ++i) {
        hash += (s[i] - 'a' + 1) * p_pow;
        p_pow *= p;
    }

    return hash;
}

/// @brief Polynomial hash function.
/// @param s
/// @return polynomial hash of the @a `s`
constexpr uint64_t polynomial_hash_safe(std::string_view s) noexcept {
    constexpr uint64_t p = impl::kPrime;
    uint64_t hash        = 0;
    uint64_t p_pow       = 1;
    for (char c : s) {
        hash += (uint32_t(uint8_t(c)) - 'a' + 1) * p_pow;
        p_pow *= p;
    }

    return hash;
}

/// @brief Functions that generates @a `size` strings with the same
///        hash as @a `str` has. Hash functions is @fn polynomial_hash.
/// @tparam Seed optional argument that may change generated set of string.
/// @param str Initial string.
///            If empty, and Seed = @ref impl::kDefaultStartN,
///            then @a `size` strings with hash = 0 will be generated.
/// @param size Number of strings that should be generated.
/// @return vector of @a `size` pairwise different strings,
///         each one has the same hash as @a `str` has.
template <uint32_t Seed = impl::kDefaultStartN>
std::vector<std::string> generate_strings_with_same_hash(std::string_view str = "",
                                                         uint32_t size = kDefaultSize) {
#if GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
    static_assert(polynomial_hash_safe(impl::zero_hash_string<Seed>) == 0);
    static_assert(impl::zero_hash_string<Seed>.size() <= impl::kMaxZeroRemStringSize);
#endif

    std::string accum_string;
    accum_string.reserve(str.size() + impl::zero_hash_string<Seed>.size() * size);
    accum_string = str;

    std::vector<std::string> res;
    res.reserve(size);
    for (uint32_t i = 0; i < size; i++) {
        accum_string += impl::zero_hash_string<Seed>;
        res.push_back(accum_string);
    }

    /**
     * This is commented by default in case NDEBUG was not turned off unintentionally.
     */
    // for (const auto& str_i : res) {
    //     assert(polynomial_hash_safe(str_i) == polynomial_hash_safe(str));
    // }

    return res;
}

}  // namespace collisions_gen

#undef GENERATE_ZERO_HASH_STRING_AT_COMPILE_TIME
