#include <cassert>
#include <cstdint>
#include <cmath>
#include <iostream>
#include <vector>
#include <string>
#include <complex>
#include <cstring>

using f64 = double;
using f128 = long double;
using real = f64;
using complex = std::complex<real>;
using std::vector;
using std::string;
using std::cin, std::cout;

#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

// static uint32_t starts_cnt[2048] = {};

inline static uint64_t NearestTwoPowGreaterEqual(uint64_t n) noexcept {
    return 1ull << (64 - __builtin_clzll(n) - ((n & (n - 1)) == 0));
}

inline static constexpr std::pair<size_t, size_t> MinMax(size_t a, size_t b) {
    return b < a ? std::pair(b, a) : std::pair(a, b);
}

void ForwardFFT(vector<complex>& p, const vector<complex>& points) {
    const size_t k = p.size();
    assert(k != 0 && (k & (k - 1)) == 0);
    for (size_t i = 1, j = 0; i < k; i++) {
        size_t bit = k >> 1;
        for (; j >= bit; bit >>= 1) {
            j -= bit;
        }

        j += bit;
        if (i < j) {
            std::swap(p[i], p[j]);
        }
    }

    for (size_t step = 1, point_step = k / 2; step < k; step *= 2, point_step /= 2) {
        for (size_t block_start = 0; block_start < k; ) {
            size_t point_start = 0;
            size_t block_end = block_start + step;

            for (size_t pos_in_block = block_start; pos_in_block < block_end; pos_in_block++) {
                auto p0_i = p[pos_in_block];
                // starts_cnt[point_start]++;
                auto w_j_p1_i = points[point_start] * p[pos_in_block + step];
                p[pos_in_block] = p0_i + w_j_p1_i;
                p[pos_in_block + step] = p0_i - w_j_p1_i;
                point_start += point_step;
            }

            block_start = block_end + step;
        }
    }
}

void BackwardFFT(vector<complex>& p, const vector<complex>& points) {
    const size_t k = p.size();
    assert(k != 0 && (k & (k - 1)) == 0);
    for (size_t i = 1, j = 0; i < k; i++) {
        size_t bit = k >> 1;
        for (; j >= bit; bit >>= 1) {
            j -= bit;
        }

        j += bit;
        if (i < j) {
            std::swap(p[i], p[j]);
        }
    }

    for (size_t step = 1, point_step = k / 2; step < k; step *= 2, point_step /= 2) {
        for (size_t block_start = 0; block_start < k; ) {
            size_t point_start = 0;
            size_t block_end = block_start + step;

            for (size_t pos_in_block = block_start; pos_in_block < block_end; pos_in_block++) {
                auto p0_i = p[pos_in_block];
                auto w_j_p1_i = points[point_start] * p[pos_in_block + step];
                p[pos_in_block] = p0_i + w_j_p1_i;
                p[pos_in_block + step] = p0_i - w_j_p1_i;
                point_start += point_step;
            }

            block_start = block_end + step;
        }
    }

    real one_kth = 1.0 / real(k);
    for (complex& p_i : p) {
        p_i *= one_kth;
    }
}

struct Number {
    string digits;

    inline Number() = default;

    inline explicit Number(const char* s) : digits(s) {
    }

    inline explicit Number(const string& s) : digits(s) {
    }

    inline explicit Number(string&& s) : digits(std::move(s)) {
    }

    Number operator*(const Number& other) {
        if (unlikely(digits.empty() || digits.front() == '0'
            || other.digits.empty() || other.digits.front() == '0')) {
            return Number("0");
        }

        const size_t n = NearestTwoPowGreaterEqual(digits.size() + other.digits.size());
        vector<complex> p1(n);
#if THREE_NLOGN_FFT
        auto iter = p1.begin() + (digits.size() - 1);
        for (char c : digits) {
            *iter = real(c - '0');
            --iter;
        }
        vector<complex> p2(n);
        iter = p2.begin() + (other.digits.size() - 1);
        for (char c : other.digits) {
            *iter = real(c - '0');
            --iter;
        }

        vector<complex> points(n);
        {
            complex w = std::exp(complex(0, 2 * real(acosl(-1)) / real(n)));
            points[0] = 1;
            points[1] = w;
            complex current = w;
            for (size_t i = 2; i < n; i++) {
                current *= w;
                points[i] = current;
            }
        }

        // if (n >= 4 && n <= 32) { for (size_t i = 0; i < n; i++) { cout << '(' << p1[i].real() << ',' << p2[i].real() << ") "; } cout << "\n\n"; }
    
        ForwardFFT(p1, points);
        ForwardFFT(p2, points);

        for (size_t i = 0; i < n; i++) {
            p1[i] *= p2[i];
        }

        // for (size_t i = 0; i < n; i++) { points[i] = 1.0 / points[i]; }
        for (size_t i = 1, h = n / 2; i < h; i++) { std::swap(points[i], points[n - i]); }
        BackwardFFT(p1, points);

        char* buffer = static_cast<char*>(malloc(n + 1));
        buffer[n] = '\0';
        char* ptr = buffer + n;
        size_t length = 0;
        uint64_t carry = 0;
        for (const auto& m_i : p1) {
            auto m = uint64_t(m_i.real() + 0.5) + carry;
            *--ptr = char(m % 10 + '0');
            length++;
            carry = m / 10;
        }
#else
        auto [min_sz, max_sz] = MinMax(digits.size(), other.digits.size());
        size_t diff = max_sz - min_sz;

        auto number_1_digits_iter = digits.cbegin();
        auto number_2_digits_iter = other.digits.begin();
        auto iter = p1.begin() + (max_sz - 1);
        if (digits.size() == max_sz) {
            while (diff-- != 0) {
                *iter = complex(*number_1_digits_iter - '0', 0);
                --iter;
                ++number_1_digits_iter;
            }
        }
        else {
            while (diff-- != 0) {
                *iter = complex(0, *number_2_digits_iter - '0');
                --iter;
                ++number_2_digits_iter;
            }
        }

        // assert(iter == (p1.begin() + (min_sz - 1)));
        while (min_sz-- != 0) {
            *iter = complex(*number_1_digits_iter - '0', *number_2_digits_iter - '0');
            --iter;
            ++number_1_digits_iter;
            ++number_2_digits_iter;
        }

        // if (n >= 4 && n <= 32) { for (const auto& p_i : p1) { cout << p_i << ' '; } cout << '\n'; }

        vector<complex> points(n);
        {
            complex w = std::exp(complex(0, 2 * real(acosl(-1)) / real(n)));
            points[0] = 1;
            points[1] = w;
            complex current = w;
            for (size_t i = 2; i < n; i++) {
                current *= w;
                points[i] = current;
            }
        }

        ForwardFFT(p1, points);

        /*
            * A(w^j) = a_0 + a_1 * w^j + a_2 * w^{2 j} + ... + a_{n - 1} * w^{(n - 1) j}
            * B(w^j) = b_0 + b_1 * w^j + b_2 * w^{2 j} + ... + b_{n - 1} * w^{(n - 1) j}
            * 
            * P = A + B * i = [ A(w^0) + B(w^0) * i, A(w^1) + B(w^1) * i, ... A(w^(n - 1)) + B(w^(n - 1)) * i ]
            * 
            * P(w^j) + conj(P(w^{n - j})) =
            * = A(w^j) + B(w^j) * i + conj(A(w^{n - j}) + B(w^{n - j}) * i) =
            * = \sum{k=0}{n-1} (a_k + b_k * i) * w^{jk} + \sum{k=0}{n-1} conj((a_k + b_k * i) * w^{(n - j)k}) =
            * = \sum{k=0}{n-1} (a_k + b_k * i) * w^{jk} + \sum{k=0}{n-1} conj((a_k + b_k * i) * w^{-jk}) =
            * = \sum{k=0}{n-1} (a_k + b_k * i) * w^{jk} + conj((a_k + b_k * i) * w^{-jk}) =
            * = \sum{k=0}{n-1} (a_k + b_k * i) * w^{jk} + conj(a_k + b_k * i) * conj(w^{-jk}) =
            * = \sum{k=0}{n-1} (a_k + b_k * i) * w^{jk} + (a_k - b_k * i) * w^{jk} =
            * = \sum{k=0}{n-1} 2 a_k * w^{jk} = 2 * A(w^j)
            * 
            * \implies A(w^j) = (P(w^j) + conj(P(w^{n - j}))) / 2
            * 
            * By analogy it is can be proved that A(w^j) = (P(w^j) - conj(P(w^{n - j}))) / (2 * i)
            * 
            * C(w^j) = A(w^j) * B(w^j) \implies C(w^j) = 
            * = (P(w^j) + conj(P(w^{n - j}))) / 2 * (P(w^j) - conj(P(w^{n - j}))) / (2 * i) =
            * = (P(w^j) + conj(P(w^{n - j}))) * (P(w^j) - conj(P(w^{n - j}))) / (4 * i) =
            * = (P(w^j) + conj(P(w^{n - j}))) * (P(w^j) - conj(P(w^{n - j}))) / (4 * i) =
            */

        vector<complex> p2(n);
        complex one_quat_i = complex(0, -0.25); // 1 / (4 * i) == -i / 4
        for (size_t j = 0; j < n; j++) {
            size_t n_j = (n - j) & (n - 1); // <=> mod n because n is power of two
            complex p_w_j = p1[j];
            complex p_w_n_j = std::conj(p1[n_j]);
            p2[j] = (p_w_j + p_w_n_j) * (p_w_j - p_w_n_j) * one_quat_i;
        }

        // for (size_t i = 0; i < n; i++) { points[i] = 1.0 / points[i]; }
        for (size_t i = 1, h = n / 2; i < h; i++) { std::swap(points[i], points[n - i]); }
        BackwardFFT(p2, points);

        char* buffer = static_cast<char*>(malloc(n + 1));
        buffer[n] = '\0';
        char* ptr = buffer + n;
        size_t length = 0;
        uint64_t carry = 0;
        for (const auto& m_i : p2) {
            auto m = uint64_t(m_i.real() + 0.5) + carry;
            *--ptr = char(m % 10 + '0');
            length++;
            carry = m / 10;
        }
#endif
        while (ptr != buffer + n && *ptr == '0') {
            ptr++;
            length--;
        }

        string str(ptr, length);
        free(buffer);
        return Number(std::move(str));
    }

    inline friend std::istream& operator>>(std::istream& in, Number& n) {
        in >> n.digits;
        return in;
    }

    inline friend std::ostream& operator<<(std::ostream& out, const Number& n) {
        out << n.digits;
        return out;
    }
};

[[maybe_unused]] static void TestNumber() {
    const char* tests[][3] = {
        { "0", "0", "0" },
        { "0", "1", "0" },
        { "1", "0", "0" },
        { "0", "99999999999999999999999999999999999999999999999999999999999", "0" },
        { "99999999999999999999999999999999999999999999999999999999999", "0", "0" },
        { "1", "1", "1" },
        { "2", "1", "2" },
        { "1", "2", "2" },
        { "10", "20", "200" },
        { "12", "20", "240" },
        { "1024", "4", "4096" },
        { "12000000", "20000000", "240000000000000" },
        { "13721838", "317826897", "4361169192676686" },
        { "317826897", "13721838", "4361169192676686" },
        { "131241234423234", "5984348957348", "785393344381744834046223432" },
        { "2734678246872364872368472638742364827364287648273648132318892173901848293489172492348923789614023527938467235423498238492794323784728935349239875",
            "2348902185132056348724237831450938453094157098145039751309847593814914534715981347589134057893417",
            "6423491709711598889041115876654018649432963188732726742064025989984811440018290126586200884641329217870700376754042411607663158208477573260850076156608872687420427040889726888717004048685350284582553498126187128453709828981195657834716402875" },
        { "952263744", "9359517973", "8912729627004270912" },
        { "4219788824", "2743656178", "11577649676822954672" },
        { "2968434375", "517784556", "1537009474874512500" },
        { "84505427146800725206214423388331447259",
            "279405665168189620898465228388855751530",
            "23611295082273845004407889189114051194515549345238521714122644008631003556270" },
        { "241624483789163450827236083147698994361",
            "176969948248112551859871363564234198810",
            "42760272391645166121149990905372750336999611475675972607486869021321542910410" },
        { "189745687871346578913675631984859831398756913846314756",
            "23423242342342342342342342345689457967408570698981759840534",
            "4444459230424999019002887192350710359853726020388674142289774769673240565480827228712761450490207639434131119704" },
        { "23423242342342342342342342345689457967408570698981759840534",
            "189745687871346578913675631984859831398756913846314756",
            "4444459230424999019002887192350710359853726020388674142289774769673240565480827228712761450490207639434131119704" },
        { "4979013912031336395843652482056944541917879830658888080210860546945162316784007696722472104490292115006929224505561952621549644507506157905895141883351693357671866673372387489064601790435943279753076135508734976402986590141791640275729075110301052182525982122055945308822786348774541301190917267056010293522021711953908722426988170600486754359151355279642107326020710320811965589623077577919604276793995290693241605498933690131016500499830411351885329358828099445375214953095242883288551175600040639508973290618254632656708077698032644332404531654194661240327089976520228558815070547050483607370290128880665115493428583195942214144370252680416623185742126651651971205877033380835086928683006777647705797323226637754670943913955499629956581438051579033788646418455294222226794208542773240250813577595297820571439025260443186083647739824886601706060545130979337849454640894799067017660651029798759710161866959877729945261418881826853299275537913940529803748601533888556248642308523858954129309895839621",
            "1089706208601124071370814153227426268538693661536077492693402002113706077836908897064010719715176055629119821718280985463346231823617831015276226748067975032405343094828082657769205252259131474831109973291257749293454119745786044094162983334244656183437048486586190591260478069683126170080375767206116766997111495034910226069855175658687975019210684025876539532495651085887043273971291745246957837630873649994471012335459828190836962052822964761370237541987899251435611120642920093504465781338431847062674488228328048386887619645965298994056431751145798374214112096174986469396938700846690701869472565650854341011865979075747215621155738285771206033348621609414969877385311942166051820149735596291338889291251880106483211920648684916159659287049528587849488130282624723754842322308381390280175920445345519401578177975718271424021934524065020159121707342876220556416710152269947564613985386481137040800062435273812000700729504595716591612580528925322234310669034643636549786097960658822655773576934232",
            "5425662372651918275299375148629540006461321920756701170286725562568759229810880572911769849537355451610005569960228002391215085052847571622689094832054985279145552749161681046861526713162440534136296490785928442215744545711439342983442729982749120390733490907009647021054311170524633132570266240806829026546139687602916900229654645538055150485456658149197560778991707820278152313692132979576603692190567330432232166508406117583864266519222289887768101694869359057868279715246089989344254809355928718476453294822032928508718003882820121545975530953496070612041244576392616141309842246017940303977167606784428044629301092398352005265891045586737344102752622286046610267838174215047313315660881597083337684595892961583985896458747267807898419659791494353138717845748556312008417645821599206848619748895452043304609685863025172031227579738617956645158235248258575509480721560219448272650065950696046407386099543681594741302423741017536949076337719309499789273159526229632009103995883101494232640178582443664188171605651617679364610071764342694526545790368273219400375205037157668346710049634975697352390763663222195249887562718049391850108222280866744148593795622184880213367433062797045761596438730675980702578848090758612689638246878037965734766568789946008561922300075077798552095915029193968953456136549672456085235618704291776967924718538238249798636597249940675408244486413603110202278103459733616978591497974412117657019479952731294916161646997813925500899342321384352570569765496029832893163507647823951079695506656446830692581049404739304276990177534134151038266962485292415265257738018558654770901977444563735949266542891330128734419196999200268758519164113373322554156512358342313975777464929251035097242190670537217696832588167811748620251129869183988486287430476024319388751623800595497573205109796023980368739722164681252677155919289466458420249924228564533145913434727157758360817904213671207456616337309903686438079934167085071256457656974379118052493980516605329326027531228264736806072" },
        { "1089706208601124071370814153227426268538693661536077492693402002113706077836908897064010719715176055629119821718280985463346231823617831015276226748067975032405343094828082657769205252259131474831109973291257749293454119745786044094162983334244656183437048486586190591260478069683126170080375767206116766997111495034910226069855175658687975019210684025876539532495651085887043273971291745246957837630873649994471012335459828190836962052822964761370237541987899251435611120642920093504465781338431847062674488228328048386887619645965298994056431751145798374214112096174986469396938700846690701869472565650854341011865979075747215621155738285771206033348621609414969877385311942166051820149735596291338889291251880106483211920648684916159659287049528587849488130282624723754842322308381390280175920445345519401578177975718271424021934524065020159121707342876220556416710152269947564613985386481137040800062435273812000700729504595716591612580528925322234310669034643636549786097960658822655773576934232",
            "4979013912031336395843652482056944541917879830658888080210860546945162316784007696722472104490292115006929224505561952621549644507506157905895141883351693357671866673372387489064601790435943279753076135508734976402986590141791640275729075110301052182525982122055945308822786348774541301190917267056010293522021711953908722426988170600486754359151355279642107326020710320811965589623077577919604276793995290693241605498933690131016500499830411351885329358828099445375214953095242883288551175600040639508973290618254632656708077698032644332404531654194661240327089976520228558815070547050483607370290128880665115493428583195942214144370252680416623185742126651651971205877033380835086928683006777647705797323226637754670943913955499629956581438051579033788646418455294222226794208542773240250813577595297820571439025260443186083647739824886601706060545130979337849454640894799067017660651029798759710161866959877729945261418881826853299275537913940529803748601533888556248642308523858954129309895839621",
            "5425662372651918275299375148629540006461321920756701170286725562568759229810880572911769849537355451610005569960228002391215085052847571622689094832054985279145552749161681046861526713162440534136296490785928442215744545711439342983442729982749120390733490907009647021054311170524633132570266240806829026546139687602916900229654645538055150485456658149197560778991707820278152313692132979576603692190567330432232166508406117583864266519222289887768101694869359057868279715246089989344254809355928718476453294822032928508718003882820121545975530953496070612041244576392616141309842246017940303977167606784428044629301092398352005265891045586737344102752622286046610267838174215047313315660881597083337684595892961583985896458747267807898419659791494353138717845748556312008417645821599206848619748895452043304609685863025172031227579738617956645158235248258575509480721560219448272650065950696046407386099543681594741302423741017536949076337719309499789273159526229632009103995883101494232640178582443664188171605651617679364610071764342694526545790368273219400375205037157668346710049634975697352390763663222195249887562718049391850108222280866744148593795622184880213367433062797045761596438730675980702578848090758612689638246878037965734766568789946008561922300075077798552095915029193968953456136549672456085235618704291776967924718538238249798636597249940675408244486413603110202278103459733616978591497974412117657019479952731294916161646997813925500899342321384352570569765496029832893163507647823951079695506656446830692581049404739304276990177534134151038266962485292415265257738018558654770901977444563735949266542891330128734419196999200268758519164113373322554156512358342313975777464929251035097242190670537217696832588167811748620251129869183988486287430476024319388751623800595497573205109796023980368739722164681252677155919289466458420249924228564533145913434727157758360817904213671207456616337309903686438079934167085071256457656974379118052493980516605329326027531228264736806072" },
        { "39874589736285746348537648975364987536485463475689312758346175316947648753619457374157823617426913817847816718871267134057345147516847576813468751364056130456875613458136745",
            "348",
            "13876357228227439729291101843427015662696941289539880839904469010297781766259571166206922618864566008611040218167200962651956111335862956731087125474691533398992713483431587260" },
        { "348",
            "39874589736285746348537648975364987536485463475689312758346175316947648753619457374157823617426913817847816718871267134057345147516847576813468751364056130456875613458136745",
            "13876357228227439729291101843427015662696941289539880839904469010297781766259571166206922618864566008611040218167200962651956111335862956731087125474691533398992713483431587260" },
        { "378473591711125662205318978307400782427783753923984686802121246042271316236774444461081305720113769234627500055999892631802251943506510613041576973905140659553198302268762932232635013075121844024010844209617001387445367992616947475847556277530823124716511381308443893601036689835540126414069661052087138994082036710162383386369932806029019860996789535859361485418449897433469146302768382820057178659536255110169359845196380565725061526581227067549629866724246482931073170051376781704197212768365253140559066042002101297055200613269143572019112557085563899878475510810554198342040963733144408262697470764570314944593526613934419263025337497357042571717671759023883586867451377168248733405883910296788303702062215452776471512256941837484725160214833729957202282648704994064553439348115504885342193852929906418451561210887575546337507615915632010857173564415901485308965735447198738488397867151647504526550040119974630239332996345427278593883623686974957277376278631354869639366838460468748101319039408427701123993442888448154403121426916704627733981704445112370876108453961872801955347846801218254087739489562170030806198132295724995482071830436648020515150300468035898691623269527628850137584131992179304108104221244082970339981314645",
            "242422360745395402404187893934203477400974449065647049988927198970319805753149705988973274875934705741319528222056518230978113788601185987597650863481917975147889480918426062465619374716968961931781307592900017970779362645595784950197534818861618814548119308868190069641017565582001182178863908348366042579709934563168161190371007834351658980901439537387725151710448936716057525234422021079168107409249681886185803656798184787755755302137461956528885902748067318538923549260818296551459793281096136811002727591059360446183594804912759682504651810130132241402424826964162913576719514934406842887250631366029807679608779995452685983217009380013356826166862603999974178446346927185519163124450042997576507464420018043214571816883931340327689828911413087854407416013902322113202969761256247555360669534677298033285373411229119624362114218631744679287995208711756999916330336680306667802886976862157913540009816489722867943929152313666052647540305002671654304297771170195703695712037696137032492879795700752067767022685233264574030743197818202098648173117308846148560570005975871944017411174794281674815109904233256841885601132453369966630233504941985437823039274173244307950067942092770927309358035074043249749436812689885822328999166497",
            "91750461582399996481249056069552341061631977362166795955654445790264222859720389211624815079283843625975863399889074212216266297134990815564761330594156985225047530954070381961437148213195600057969015010386733547822475958080115840136741686692338859325504867646221723989400550500929317397416221571891625767783321077342877108720012126080679211874940105656574765376297890689604436113946845444191558673952067190703736606117892318167589626611808999592345128060713013723521842461568316927463862910923034086153951336451168076535477516830914439285093043762990954039413381588521712360446061593810377394657345416121564517043424860788547525235085792343018997727948065012605965408721320163051985218148442070481328417606499793006079912309477825377935641101410477501161932089027628535008552104222618408935767393335060030694945758378704672264522319383457997330369049702343188167604623366678376120989861617610630672930536465566980876948021796581916334213547308250522630241086319046806456977746512235528072488535874371368947268698209015357823085409795719588097028234042794879605958978464183072895599180811154590444271971396865304247122008224327128637067378970116215511700712030353712423319327512511897289586567993904360468930853505705469168815995897919297049268364364202469557536979483426732147221671109127696683092476140491126818755624998935111987394755116214733724671355006980468468795377673992716072110654551008812212873841685531210505119906739350111475048911270730349061872269078463062821935188053118917685774942151561764762561390599264509475929928149502026146850838330252467296169912031042785085004360846295411799159444104152561578205952489721730980991738242222877578374533496541619714851354580401742391750350373448393935628587788954777352482566911435843918432923932547136028133093518824417001358921720176306869776325301163185814759856575836089499945845246719250766361998726161201416467077119735405112368483599218727089596693298272073242067820420384714345537586697308993657001146038822806716503143415537504249771740386887313648047613127969728987677190328129661590559820669047704931339203348331237658184130719236353882236820168212391548475189594072837236345386281884700821238193120175068335949608964486690094889051463543949903889705367037538550238926930991984064029903921425133938921567363993240377805736468371128960994609947805802949073455360925189610758755620972319942874745920155808369257461687434973249064848189008369934903417392669574477053593427918093472288422759299448565" },
    };

    for (const char *const (&test)[3] : tests) {
        auto res = Number(test[0]) * Number(test[1]);
        if (res.digits != test[2]) {
            cout << test[2] << ' ' << strlen(test[2]) << '\n';
            cout << res.digits << ' ' << res.digits.size() << '\n';
            break;
        }
    }

    // for (size_t i = 0; i < 2048; i++) {
    //     auto cnt = starts_cnt[i];
    //     if (cnt) {
    //         cout << "p_cnt[" << i << "] = " << cnt << '\n';
    //     }
    // }
}

int main() {
    // TestNumber();
    Number d1;
    cin >> d1;
    Number d2;
    cin >> d2;
    cout << d1 * d2;
}
