#define NDEBUG 1

#include <cassert>
#include <cstdint>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>

using u32 = uint32_t;
using u64 = uint64_t;
using std::string;
using std::cin, std::cout;

inline constexpr size_t MAX_N = 5e4;
inline constexpr u64 BASE = 1'000'000'000;
inline constexpr int32_t DIGITS = 9;

void __knummul(const u32* num1, const u32* num2, size_t n, u32* ans) {
    switch (n) {
        case 0:
            ans[0] = 0;
            return;
        case 1: {
            u64 res = u64(num1[0]) * u64(num2[0]);
            assert(res < BASE * BASE);
            ans[0] = u32(res % BASE);
            ans[1] = u32(res / BASE);
            return;
        }
        case 2:
        case 3:
        case 4: {
            for (size_t j = 0; j < n; j++) {
                u64 carry = 0;
                u64 carry1 = 0;
                u64 b_j = num2[j];
                for (size_t i = 0; i < n; i++) {
                    u64 a_i = num1[i];
                    u64 res = b_j * a_i + carry;
                    carry = res / BASE;
                    u64 sum = ans[i + j] + res % BASE + carry1;
                    carry1 = sum / BASE;
                    ans[i + j] = u32(sum % BASE);
                }

                u64 sum = ans[j + n] + carry + carry1;
                carry1 = sum / BASE;
                ans[j + n + (j + 1 != n)] = u32(carry1 % BASE);
                ans[j + n] = u32(sum % BASE);
            }
            return;
        }
    }

    const size_t low_sz = n >> 1;
    const u32* a2 = num1;
    size_t a2_size = low_sz;
    const u32* b2 = num2;
    size_t b2_size = low_sz;
    size_t a2b2_size = 2 * low_sz;
    assert(a2b2_size == n - (n & 1));
    u32* const a2b2 = ans;
    __knummul(a2, b2, low_sz, a2b2);

    const size_t hi_sz = n - low_sz;
    const u32* a1 = num1 + low_sz;
    size_t a1_size = hi_sz;
    const u32* b1 = num2 + low_sz;
    size_t b1_size = hi_sz;
    size_t a1b1_size = 2 * hi_sz;
    assert(a1b1_size == n + (n & 1));
    u32* const a1b1 = ans + a2b2_size;
    assert(a1b1 != nullptr);
    __knummul(a1, b1, hi_sz, a1b1);

    assert(a1_size >= a2_size);
    const size_t sum_size = hi_sz + 1;
    assert(sum_size == (n - n / 2) + 1);
    u32* const a1_p_a2 = static_cast<u32*>(malloc(4 * sum_size * sizeof(u32)));
    assert(a1_p_a2 != nullptr);
    {
        u64 res;
        u64 carry = 0;
        u32* a1_p_a2_p = a1_p_a2;
        const u32* a1_ptr = a1;
        const u32* a2_ptr = a2;
        for (size_t i = 0; i < a2_size; i++) {
            assert(a1_ptr < num1 + n);
            assert(a2_ptr < num1 + n);
            res = u64(*a1_ptr) + u64(*a2_ptr) + carry;
            *a1_p_a2_p = u32(res % BASE);
            a1_p_a2_p++;
            a1_ptr++;
            a2_ptr++;
            carry = res / BASE;
        }

        size_t limit = a1_size - a2_size;
        // Optimize while (carry != 0) + memset 0
        while (limit-- != 0) {
            assert(a1_ptr < num1 + n);
            res = *a1_ptr + carry;
            a1_ptr++;
            *a1_p_a2_p = u32(res % BASE);
            a1_p_a2_p++;
            carry = res / BASE;
        }

        *a1_p_a2_p = u32(carry);
    }

    assert(b1_size >= b2_size);
    u32* const b1_p_b2 = a1_p_a2 + sum_size;
    assert(b1_p_b2 != nullptr);
    {
        u64 res;
        u64 carry = 0;
        u32* b1_p_b2_p = b1_p_b2;
        const u32* b1_ptr = b1;
        const u32* b2_ptr = b2;
        for (size_t i = 0; i < b2_size; i++) {
            assert(b1_ptr < num2 + n);
            assert(b2_ptr < num2 + n);
            res = u64(*b1_ptr) + u64(*b2_ptr) + carry;
            *b1_p_b2_p = u32(res % BASE);
            b1_p_b2_p++;
            b1_ptr++;
            b2_ptr++;
            carry = res / BASE;
        }

        size_t limit = b1_size - b2_size;
        // Optimize while (carry != 0) + memset 0
        while (limit-- != 0) {
            assert(b1_ptr < num2 + n);
            res = u64(*b1_ptr) + carry;
            b1_ptr++;
            *b1_p_b2_p = u32(res % BASE);
            b1_p_b2_p++;
            carry = res / BASE;
        }

        *b1_p_b2_p = u32(carry);
    }

    bool p = sum_size > 1 && a1_p_a2[sum_size - 1] == 0 && b1_p_b2[sum_size - 1] == 0;
    u32* const t = b1_p_b2 + sum_size;
    size_t t_size = (sum_size - p) * 2;
    memset(t, 0, t_size * sizeof(u32));
    __knummul(a1_p_a2, b1_p_b2, (sum_size - p), t);

    {
        assert(t_size >= a1b1_size && a1b1_size >= a2b2_size);
        u64 carry = 0;
        u64 res;
        u32* n1_ptr = t;
        const u32* n2_ptr = a1b1;
        const u32* n3_ptr = a2b2;

        size_t limit = a2b2_size;
        while (limit--) {
            assert(n1_ptr < t + t_size);
            res = *n1_ptr;
            assert(n2_ptr < a1b1 + a1b1_size);
            assert(n3_ptr < a2b2 + a2b2_size);
            u64 sub = u64(*n2_ptr) + u64(*n3_ptr) + carry;
            carry = 0;
            if (res < sub) {
                res += BASE; carry++;
                if (res < sub) {
                    res += BASE; carry++;
                }
            }

            assert(res >= sub);
            *n1_ptr = u32(res - sub);
            n1_ptr++;
            n2_ptr++;
            n3_ptr++;
        }

        limit = a1b1_size - a2b2_size;
        while (limit--) {
            assert(n1_ptr < t + t_size);
            res = u64(*n1_ptr);
            assert(n2_ptr < a1b1 + a1b1_size);
            assert(carry <= 2);
            u64 sub = u64(*n2_ptr) + carry;
            carry = 0;
            if (res < sub) {
                res += BASE; carry++;
                if (res < sub) {
                    res += BASE; carry++;
                }
            }

            assert(res >= sub);
            *n1_ptr = u32(res - sub);
            n1_ptr++;
            n2_ptr++;
        }

        limit = t_size - a1b1_size;
        while (limit-- && carry != 0){
            assert(n1_ptr < t + t_size);
            res = u64(*n1_ptr);
            u64 sub = carry;
            carry = 0;
            if (res < sub) {
                res += BASE; carry++;
            }

            assert(res >= sub);
            *n1_ptr = u32(res - sub);
            n1_ptr++;
        }

        assert(carry == 0);
    }

    while (t_size != 0 && t[t_size - 1] == 0) {
        t_size--;
    }

    u32* ans_p = ans + n / 2;
    u64 carry = 0;
    assert(t_size <= n + 2 + n % 2);
    for (const u32* t_iter = t, *t_iter_end = t + t_size; t_iter != t_iter_end; ++t_iter) {
        assert(ans_p < ans + 2 * n);
        u64 res = u64(*ans_p) + u64(*t_iter) + carry;
        *ans_p = u32(res % BASE);
        ans_p++;
        carry = res / BASE;
    }

    ssize_t limit = ssize_t(2 * n - n / 2) - ssize_t(t_size);
    while (limit-- > 0 && carry != 0) {
        assert(ans_p < ans + 2 * n);
        u64 res = u64(*ans_p) + carry;
        *ans_p = u32(res % BASE);
        ans_p++;
        carry = res / BASE;
    }

    free(a1_p_a2);
    assert(carry == 0);
}

inline string knummul(const string& s1, const string& s2) {
    assert(!s1.empty() && !s2.empty());
    size_t m = (std::max(s1.size(), s2.size()) + DIGITS - 1) / DIGITS;

    u32* num1 = static_cast<u32*>(malloc(4 * m * sizeof(u32)));
    memset(num1, 0, 4 * m * sizeof(u32));

    u32* num2 = num1 + m;
    {
        const char* s_p = s1.data() + s1.size();
        u32* num_p = num1;
        for (size_t limit = s1.size() / DIGITS; limit != 0; limit--) {
            u32 a = 0;
            for (size_t j = DIGITS; j != 0; j--) {
                a = a * 10 + u32(*(s_p - j) - '0');
            }
            s_p -= DIGITS;
            *num_p = a;
            num_p++;
        }

        u32 la = 0;
        for (size_t j = s1.size() % DIGITS; j != 0; j--) {
            la = la * 10 + u32(*(s_p - j) - '0');
        }
        if (la) {
            *num_p = la;
            num_p++;
        }
        assert(num_p <= num1 + m);

        s_p = s2.data() + s2.size();
        num_p = num2;
        for (size_t limit = s2.size() / DIGITS; limit != 0; limit--) {
            u32 a = 0;
            for (size_t j = DIGITS; j != 0; j--) {
                a = a * 10 + u32(*(s_p - j) - '0');
            }
            s_p -= DIGITS;
            *num_p = a;
            num_p++;
        }

        la = 0;
        for (size_t j = s2.size() % DIGITS; j != 0; j--) {
            la = la * 10 + u32(*(s_p - j) - '0');
        }
        if (la) {
            *num_p = la;
            num_p++;
        }
        assert(num_p <= num2 + m);
    }

    u32* mult = num2 + m;
    __knummul(num1, num2, m, mult);
    size_t number_size = 2 * m;
    while (number_size > 1 && mult[number_size - 1] == 0) {
        number_size--;
    }

    u32 digits_count = 0;
    {
        u32 d = mult[number_size - 1];
        assert(d < BASE);
        do {
            digits_count++;
            d /= 10;
        } while (d);
    }

    string ans((number_size - 1) * DIGITS + digits_count, '\0');
    char* ans_p = ans.data() + ans.size();
    for (size_t limit = number_size - 1; limit != 0; limit--) {
        u32 d = *mult;
        for (size_t j = DIGITS; j != 0; j--) {
            assert(ans_p - 1 >= ans.data());
            *--ans_p = char(d % 10 + '0');
            d /= 10;
        }
        mult++;
    }

    u32 d = *mult;
    while (digits_count-- != 0) {
        assert(ans_p - 1 >= ans.data());
        *--ans_p = char(d % 10 + '0');
        d /= 10;
    }

    free(num1);
    return ans;
}

struct Number {
    string digits;

    inline Number() = default;

    inline explicit Number(const char* s) : digits(s) {
    }

    inline explicit Number(const string& s) : digits(s) {
    }

    inline explicit Number(string&& s) : digits(std::move(s)) {
    }

    Number operator*(const Number& other) {
        return Number(knummul(digits, other.digits));
    }

    inline friend std::istream& operator>>(std::istream& in, Number& n) {
        in >> n.digits;
        return in;
    }

    inline friend std::ostream& operator<<(std::ostream& out, const Number& n) {
        out << n.digits;
        return out;
    }
};

[[maybe_unused]] static inline void tests() {
    const char* test_cases[][3] = {
        { "0", "0", "0" },
        { "0", "1", "0" },
        { "1", "0", "0" },
        { "0", "99999999999999999999999999999999999999999999999999999999999", "0" },
        { "99999999999999999999999999999999999999999999999999999999999", "0", "0" },
        { "1", "1", "1" },
        { "2", "1", "2" },
        { "1", "2", "2" },
        { "10", "20", "200" },
        { "12", "20", "240" },
        { "1024", "4", "4096" },
        { "12000000", "20000000", "240000000000000" },
        { "13721838", "317826897", "4361169192676686" },
        { "317826897", "13721838", "4361169192676686" },
        { "131241234423234", "5984348957348", "785393344381744834046223432" },
        { "2734678246872364872368472638742364827364287648273648132318892173901848293489172492348923789614023527938467235423498238492794323784728935349239875",
            "2348902185132056348724237831450938453094157098145039751309847593814914534715981347589134057893417",
            "6423491709711598889041115876654018649432963188732726742064025989984811440018290126586200884641329217870700376754042411607663158208477573260850076156608872687420427040889726888717004048685350284582553498126187128453709828981195657834716402875" },
        { "952263744", "9359517973", "8912729627004270912" },
        { "4219788824", "2743656178", "11577649676822954672" },
        { "2968434375", "517784556", "1537009474874512500" },
        { "84505427146800725206214423388331447259",
            "279405665168189620898465228388855751530",
            "23611295082273845004407889189114051194515549345238521714122644008631003556270" },
        { "241624483789163450827236083147698994361",
            "176969948248112551859871363564234198810",
            "42760272391645166121149990905372750336999611475675972607486869021321542910410" },
        { "189745687871346578913675631984859831398756913846314756",
            "23423242342342342342342342345689457967408570698981759840534",
            "4444459230424999019002887192350710359853726020388674142289774769673240565480827228712761450490207639434131119704" },
        { "23423242342342342342342342345689457967408570698981759840534",
            "189745687871346578913675631984859831398756913846314756",
            "4444459230424999019002887192350710359853726020388674142289774769673240565480827228712761450490207639434131119704" },
        { "4979013912031336395843652482056944541917879830658888080210860546945162316784007696722472104490292115006929224505561952621549644507506157905895141883351693357671866673372387489064601790435943279753076135508734976402986590141791640275729075110301052182525982122055945308822786348774541301190917267056010293522021711953908722426988170600486754359151355279642107326020710320811965589623077577919604276793995290693241605498933690131016500499830411351885329358828099445375214953095242883288551175600040639508973290618254632656708077698032644332404531654194661240327089976520228558815070547050483607370290128880665115493428583195942214144370252680416623185742126651651971205877033380835086928683006777647705797323226637754670943913955499629956581438051579033788646418455294222226794208542773240250813577595297820571439025260443186083647739824886601706060545130979337849454640894799067017660651029798759710161866959877729945261418881826853299275537913940529803748601533888556248642308523858954129309895839621",
            "1089706208601124071370814153227426268538693661536077492693402002113706077836908897064010719715176055629119821718280985463346231823617831015276226748067975032405343094828082657769205252259131474831109973291257749293454119745786044094162983334244656183437048486586190591260478069683126170080375767206116766997111495034910226069855175658687975019210684025876539532495651085887043273971291745246957837630873649994471012335459828190836962052822964761370237541987899251435611120642920093504465781338431847062674488228328048386887619645965298994056431751145798374214112096174986469396938700846690701869472565650854341011865979075747215621155738285771206033348621609414969877385311942166051820149735596291338889291251880106483211920648684916159659287049528587849488130282624723754842322308381390280175920445345519401578177975718271424021934524065020159121707342876220556416710152269947564613985386481137040800062435273812000700729504595716591612580528925322234310669034643636549786097960658822655773576934232",
            "5425662372651918275299375148629540006461321920756701170286725562568759229810880572911769849537355451610005569960228002391215085052847571622689094832054985279145552749161681046861526713162440534136296490785928442215744545711439342983442729982749120390733490907009647021054311170524633132570266240806829026546139687602916900229654645538055150485456658149197560778991707820278152313692132979576603692190567330432232166508406117583864266519222289887768101694869359057868279715246089989344254809355928718476453294822032928508718003882820121545975530953496070612041244576392616141309842246017940303977167606784428044629301092398352005265891045586737344102752622286046610267838174215047313315660881597083337684595892961583985896458747267807898419659791494353138717845748556312008417645821599206848619748895452043304609685863025172031227579738617956645158235248258575509480721560219448272650065950696046407386099543681594741302423741017536949076337719309499789273159526229632009103995883101494232640178582443664188171605651617679364610071764342694526545790368273219400375205037157668346710049634975697352390763663222195249887562718049391850108222280866744148593795622184880213367433062797045761596438730675980702578848090758612689638246878037965734766568789946008561922300075077798552095915029193968953456136549672456085235618704291776967924718538238249798636597249940675408244486413603110202278103459733616978591497974412117657019479952731294916161646997813925500899342321384352570569765496029832893163507647823951079695506656446830692581049404739304276990177534134151038266962485292415265257738018558654770901977444563735949266542891330128734419196999200268758519164113373322554156512358342313975777464929251035097242190670537217696832588167811748620251129869183988486287430476024319388751623800595497573205109796023980368739722164681252677155919289466458420249924228564533145913434727157758360817904213671207456616337309903686438079934167085071256457656974379118052493980516605329326027531228264736806072" },
        { "1089706208601124071370814153227426268538693661536077492693402002113706077836908897064010719715176055629119821718280985463346231823617831015276226748067975032405343094828082657769205252259131474831109973291257749293454119745786044094162983334244656183437048486586190591260478069683126170080375767206116766997111495034910226069855175658687975019210684025876539532495651085887043273971291745246957837630873649994471012335459828190836962052822964761370237541987899251435611120642920093504465781338431847062674488228328048386887619645965298994056431751145798374214112096174986469396938700846690701869472565650854341011865979075747215621155738285771206033348621609414969877385311942166051820149735596291338889291251880106483211920648684916159659287049528587849488130282624723754842322308381390280175920445345519401578177975718271424021934524065020159121707342876220556416710152269947564613985386481137040800062435273812000700729504595716591612580528925322234310669034643636549786097960658822655773576934232",
            "4979013912031336395843652482056944541917879830658888080210860546945162316784007696722472104490292115006929224505561952621549644507506157905895141883351693357671866673372387489064601790435943279753076135508734976402986590141791640275729075110301052182525982122055945308822786348774541301190917267056010293522021711953908722426988170600486754359151355279642107326020710320811965589623077577919604276793995290693241605498933690131016500499830411351885329358828099445375214953095242883288551175600040639508973290618254632656708077698032644332404531654194661240327089976520228558815070547050483607370290128880665115493428583195942214144370252680416623185742126651651971205877033380835086928683006777647705797323226637754670943913955499629956581438051579033788646418455294222226794208542773240250813577595297820571439025260443186083647739824886601706060545130979337849454640894799067017660651029798759710161866959877729945261418881826853299275537913940529803748601533888556248642308523858954129309895839621",
            "5425662372651918275299375148629540006461321920756701170286725562568759229810880572911769849537355451610005569960228002391215085052847571622689094832054985279145552749161681046861526713162440534136296490785928442215744545711439342983442729982749120390733490907009647021054311170524633132570266240806829026546139687602916900229654645538055150485456658149197560778991707820278152313692132979576603692190567330432232166508406117583864266519222289887768101694869359057868279715246089989344254809355928718476453294822032928508718003882820121545975530953496070612041244576392616141309842246017940303977167606784428044629301092398352005265891045586737344102752622286046610267838174215047313315660881597083337684595892961583985896458747267807898419659791494353138717845748556312008417645821599206848619748895452043304609685863025172031227579738617956645158235248258575509480721560219448272650065950696046407386099543681594741302423741017536949076337719309499789273159526229632009103995883101494232640178582443664188171605651617679364610071764342694526545790368273219400375205037157668346710049634975697352390763663222195249887562718049391850108222280866744148593795622184880213367433062797045761596438730675980702578848090758612689638246878037965734766568789946008561922300075077798552095915029193968953456136549672456085235618704291776967924718538238249798636597249940675408244486413603110202278103459733616978591497974412117657019479952731294916161646997813925500899342321384352570569765496029832893163507647823951079695506656446830692581049404739304276990177534134151038266962485292415265257738018558654770901977444563735949266542891330128734419196999200268758519164113373322554156512358342313975777464929251035097242190670537217696832588167811748620251129869183988486287430476024319388751623800595497573205109796023980368739722164681252677155919289466458420249924228564533145913434727157758360817904213671207456616337309903686438079934167085071256457656974379118052493980516605329326027531228264736806072" },
        { "39874589736285746348537648975364987536485463475689312758346175316947648753619457374157823617426913817847816718871267134057345147516847576813468751364056130456875613458136745",
            "348",
            "13876357228227439729291101843427015662696941289539880839904469010297781766259571166206922618864566008611040218167200962651956111335862956731087125474691533398992713483431587260" },
        { "348",
            "39874589736285746348537648975364987536485463475689312758346175316947648753619457374157823617426913817847816718871267134057345147516847576813468751364056130456875613458136745",
            "13876357228227439729291101843427015662696941289539880839904469010297781766259571166206922618864566008611040218167200962651956111335862956731087125474691533398992713483431587260" },
        { "378473591711125662205318978307400782427783753923984686802121246042271316236774444461081305720113769234627500055999892631802251943506510613041576973905140659553198302268762932232635013075121844024010844209617001387445367992616947475847556277530823124716511381308443893601036689835540126414069661052087138994082036710162383386369932806029019860996789535859361485418449897433469146302768382820057178659536255110169359845196380565725061526581227067549629866724246482931073170051376781704197212768365253140559066042002101297055200613269143572019112557085563899878475510810554198342040963733144408262697470764570314944593526613934419263025337497357042571717671759023883586867451377168248733405883910296788303702062215452776471512256941837484725160214833729957202282648704994064553439348115504885342193852929906418451561210887575546337507615915632010857173564415901485308965735447198738488397867151647504526550040119974630239332996345427278593883623686974957277376278631354869639366838460468748101319039408427701123993442888448154403121426916704627733981704445112370876108453961872801955347846801218254087739489562170030806198132295724995482071830436648020515150300468035898691623269527628850137584131992179304108104221244082970339981314645",
            "242422360745395402404187893934203477400974449065647049988927198970319805753149705988973274875934705741319528222056518230978113788601185987597650863481917975147889480918426062465619374716968961931781307592900017970779362645595784950197534818861618814548119308868190069641017565582001182178863908348366042579709934563168161190371007834351658980901439537387725151710448936716057525234422021079168107409249681886185803656798184787755755302137461956528885902748067318538923549260818296551459793281096136811002727591059360446183594804912759682504651810130132241402424826964162913576719514934406842887250631366029807679608779995452685983217009380013356826166862603999974178446346927185519163124450042997576507464420018043214571816883931340327689828911413087854407416013902322113202969761256247555360669534677298033285373411229119624362114218631744679287995208711756999916330336680306667802886976862157913540009816489722867943929152313666052647540305002671654304297771170195703695712037696137032492879795700752067767022685233264574030743197818202098648173117308846148560570005975871944017411174794281674815109904233256841885601132453369966630233504941985437823039274173244307950067942092770927309358035074043249749436812689885822328999166497",
            "91750461582399996481249056069552341061631977362166795955654445790264222859720389211624815079283843625975863399889074212216266297134990815564761330594156985225047530954070381961437148213195600057969015010386733547822475958080115840136741686692338859325504867646221723989400550500929317397416221571891625767783321077342877108720012126080679211874940105656574765376297890689604436113946845444191558673952067190703736606117892318167589626611808999592345128060713013723521842461568316927463862910923034086153951336451168076535477516830914439285093043762990954039413381588521712360446061593810377394657345416121564517043424860788547525235085792343018997727948065012605965408721320163051985218148442070481328417606499793006079912309477825377935641101410477501161932089027628535008552104222618408935767393335060030694945758378704672264522319383457997330369049702343188167604623366678376120989861617610630672930536465566980876948021796581916334213547308250522630241086319046806456977746512235528072488535874371368947268698209015357823085409795719588097028234042794879605958978464183072895599180811154590444271971396865304247122008224327128637067378970116215511700712030353712423319327512511897289586567993904360468930853505705469168815995897919297049268364364202469557536979483426732147221671109127696683092476140491126818755624998935111987394755116214733724671355006980468468795377673992716072110654551008812212873841685531210505119906739350111475048911270730349061872269078463062821935188053118917685774942151561764762561390599264509475929928149502026146850838330252467296169912031042785085004360846295411799159444104152561578205952489721730980991738242222877578374533496541619714851354580401742391750350373448393935628587788954777352482566911435843918432923932547136028133093518824417001358921720176306869776325301163185814759856575836089499945845246719250766361998726161201416467077119735405112368483599218727089596693298272073242067820420384714345537586697308993657001146038822806716503143415537504249771740386887313648047613127969728987677190328129661590559820669047704931339203348331237658184130719236353882236820168212391548475189594072837236345386281884700821238193120175068335949608964486690094889051463543949903889705367037538550238926930991984064029903921425133938921567363993240377805736468371128960994609947805802949073455360925189610758755620972319942874745920155808369257461687434973249064848189008369934903417392669574477053593427918093472288422759299448565" },
    };

    for (const char *const (&test)[3] : test_cases) {
        string s1 = test[0];
        string s2 = test[1];
        auto res = (Number(s1) * Number(s2));
        if (res.digits != test[2]) {
            cout << test[2] << ' ' << strlen(test[2]) << '\n';
            cout << res.digits << ' ' << res.digits.size() << '\n';
            break;
        }
    }

    constexpr size_t k = MAX_N;
    string s1(k, '9');
    string s2(s1);
    string res = knummul(s1, s2);
    assert(res.size() == 2 * k);
    bool correct = true;
    for (size_t i = 0; i < k - 1; i++) {
        correct &= res[i] == '9';
    }
    correct &= res[k - 1] == '8';
    for (size_t i = k; i < 2 * k - 1; i++) {
        correct &= res[i] == '0';
    }
    correct &= res[2 * k - 1] == '1';
    if (!correct) { cout << "Long test failed\n"; }
}

[[maybe_unused]] static inline void console() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s1, s2;
    s1.reserve(MAX_N);
    s2.reserve(MAX_N);
    cin >> s1 >> s2;
    cout << knummul(s1, s2);
    cout.flush();
}

int main() {
    tests();
    // console();
}
